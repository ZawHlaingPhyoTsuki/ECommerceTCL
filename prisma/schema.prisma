generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String     @id @default(cuid())
  name          String
  email         String     @unique
  emailVerified Boolean    @default(false)
  image         String?
  role          Role       @default(CUSTOMER)
  favorites     Favorite[]
  seller        Seller?
  sellerId      String?

  sessions Session[] // ðŸ‘‰ Better Auth relation
  accounts Account[] // ðŸ‘‰ Better Auth relation

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email]) // ðŸ‘‰ Faster email lookups (auth)
  @@index([sellerId]) // ðŸ‘‰ Joins with Seller
  @@index([createdAt]) // ðŸ‘‰ Time-based queries
  @@index([role]) // ðŸ‘‰ Added: Filter users by role
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime // ðŸ‘‰ Critical for session cleanup
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId]) // ðŸ‘‰ Faster session retrieval by user
  @@index([token]) // ðŸ‘‰ Already unique, but speeds up auth flows
  @@index([expiresAt]) // ðŸ‘‰ Critical for expiring old sessions
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountId             String // ðŸ‘‰ Provider's user ID (e.g., Google sub)
  providerId            String // ðŸ‘‰ e.g., "google", "github"
  accessToken           String? // ðŸ‘‰ Encrypt if storing sensitive data
  refreshToken          String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?
  password              String? // ðŸ‘‰ Hashed if using email/password
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@unique([providerId, accountId]) // ðŸ‘‰ Critical: Ensure one account per provider
  @@index([userId]) // ðŸ‘‰ Faster user account lookups
  @@index([providerId]) // ðŸ‘‰ Filter by provider (e.g., all Google accounts)
  @@index([accessTokenExpiresAt]) // ðŸ‘‰ Token cleanup
}

model Verification {
  id         String   @id @default(cuid())
  identifier String // ðŸ‘‰ Typically email/phone
  value      String // ðŸ‘‰ Token/OTP
  expiresAt  DateTime // ðŸ‘‰ Critical for expiration checks
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier, value]) // ðŸ‘‰ Faster verification lookups
  @@index([expiresAt]) // ðŸ‘‰ Cleanup expired tokens
}

// Keep your existing models with minor optimizations:
model Seller {
  id       String    @id @default(cuid())
  name     String
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId   String    @unique
  shopName String
  bio      String?
  products Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId]) // ðŸ‘‰ Covered by @unique but keeps queries explicit
  @@index([shopName]) // ðŸ‘‰ Faster shop search
  @@index([createdAt]) // ðŸ‘‰ Time-based sorting
}

model Product {
  id             String     @id @default(cuid())
  title          String
  slug           String     @unique
  description    String?
  imageUrl       String
  price          Int
  category       Category   @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId     String
  seller         Seller     @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  sellerId       String
  isFeatured     Boolean    @default(false)
  isArchived     Boolean    @default(false)
  favoritedBy    Favorite[]
  favoritesCount Int        @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug]) // ðŸ‘‰ Already unique, but speeds up slug lookups
  @@index([categoryId]) // ðŸ‘‰ Faster category filtering
  @@index([sellerId]) // ðŸ‘‰ Faster seller product lists
  @@index([price]) // ðŸ‘‰ Price range queries
  @@index([isFeatured]) // ðŸ‘‰ Featured product dashboards
  @@index([isArchived]) // ðŸ‘‰ Admin archival views
  @@index([favoritesCount]) // ðŸ‘‰ Popularity sorting
  @@index([createdAt]) // ðŸ‘‰ Newest product listings
}

model Category {
  id       String    @id @default(cuid())
  name     String    @unique
  slug     String    @unique
  imageUrl String
  products Product[]

  @@index([name]) // ðŸ‘‰ Covered by @unique but explicit for queries
  @@index([slug]) // ðŸ‘‰ Covered by @unique but explicit for queries
}

model Favorite {
  id        String  @id @default(cuid())
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId String

  createdAt DateTime @default(now())

  @@unique([userId, productId]) // ðŸ‘‰ Prevent duplicate favorites
  @@index([userId]) // ðŸ‘‰ User's favorite list
  @@index([productId]) // ðŸ‘‰ Product popularity metrics
  @@index([createdAt]) // ðŸ‘‰ Recent activity
}

enum Role {
  CUSTOMER
  SELLER
  ADMIN
}
